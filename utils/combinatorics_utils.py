import numpy as np
import sympy
from numpy import pi
from math import comb as binom
from math import factorial
from sympy import var, I
from typing import Callable, TypeVar
from functools import cache

# generic types
T = TypeVar('T')

def partitions(list_ : list[T], num_sublists : int):
    """
    Takes a list of different elements, and generates all partitions of that list into a given amount of non-empty sublists. 

    Parameters
    ----------
    list_ : list[T]
        A list of different values.
    num_sublists : int
        The number of sublists in the partitions

    Yields
    ------
    list[list[T]]
        A partition of list_ into num_sublists sublists. This goes over all such partitions.
    """
    if(len(set(list_)) != len(list_)):
        raise ValueError("Function partitions(...) received a list with repeating elements.")
    if(num_sublists > len(list_)):
        return
    if(num_sublists == 1):
        yield [list_]
        return
    if(num_sublists == len(list_)):
        yield [[x] for x in list_]
        return

    first = list_[0]
    for smaller_partition in partitions(list_[1:], num_sublists):
        for i, sublist in enumerate(smaller_partition):
            yield smaller_partition[:i] + [[first] + sublist] + smaller_partition[i+1:]
    # place the first element on its own
    for smaller_partition in partitions(list_[1:], num_sublists - 1):
        yield [[first]] + smaller_partition

def partitions_with_empties(list_ : list[T], num_sublists : int):
    """
    Takes a list of different elements, and generates all partitions of that list into a given amount of sublists, where sublists can be empty. 

    Parameters
    ----------
    list_ : list[T]
        A list of different values.
    num_sublists : int
        The number of sublists in the partitions

    Yields
    ------
    list[list[T]]
        A partition of list_ into num_sublists possibly-empty sublists. This goes over all such partitions.
    """
    for num_empties in range(num_sublists):
        for partition in partitions(list_, num_sublists - num_empties):
            yield [[]]*num_empties + partition

def increment_sublist_index(
        indices : list[int],
        max_index : int,
        skip : int = 0
    ):
    """
    Increments the indices for a sublist as generated by sublist_generator, in left-to-right lexicographic order.

    Parameters
    ----------
    indices : list[int]
        An increasing list of integers.
    max_index : int
        The maximum possible value for the indices.
    skip : int
        A number that determines how many indices from the right cannot be incremented.

    Returns
    -------
    boolean
        True, unless indices are all maxed out in which case this returns False.
    """
    if(skip >= len(indices)):
        raise ValueError("Received value of skip variable exceeds maximal possible value.")
    if(indices == [i + max_index - len(indices) for i in range(len(indices))]):
        return False
    incremented_index = None
    incremented_value = None
    for i in range(len(indices) - 1 - skip, -1, -1):
        if((indices[i] < max_index) and ((i == len(indices) - 1) or (indices[i] + 1 < indices[i+1]))):
            indices[i] += 1
            incremented_index = i
            incremented_value = indices[i]
            break
    new_value = incremented_value + 1
    for i in range(incremented_index+1, len(indices), 1):
        indices[i] = new_value
        new_value += 1
    return True

def sublist_generator(
        list_ : list,
        size : int
    ):
    """
    Returns a generator for sublists of a given size, of a list.

    Parameters
    ----------
    list_ : list
        A set.
    size : int
        An integer determining the size for subsets of the set.

    Yields
    ------
    list
        Subsets of the list, of the specified size, where the subsets are given by list_[indices] where indices increase in left-to-right-lexicographic order on size-tuples of different indices from 0 to len(list_) - 1.

    Notes
    -----
    The generator can receive as input a value of the form "skip = n" for an integer n. If this is given, elements will be skipped until the right-most possible index that is at least n steps from the right is increased.
    """
    length = len(list_)
    if(size > length):
        return
    indices = [i for i in range(size)]
    stop = False
    while(not stop):
        sublist = [list_[index] for index in indices]
        input = yield sublist
        if(input == None):
            stop = not increment_sublist_index(indices, len(list_) - 1)
            continue
        if(input[:4] == "skip"):
            try:
                skip = int(input.split("=")[1])
            except ValueError:
                "Generator unable to handle received value." 
            stop = not increment_sublist_index(indices, len(list_) - 1, skip)
            continue
        raise ValueError("Generator unable to handle received value.")

class PositiveIntSet():
    """
    A class for computing combinatorical data on a set of positive integers.

    Parameters
    ----------
    int_set : set[int]
        A set of positive integers.

    Attributes
    ----------
    int_set : set[int]
    sorted_list : list[int]
        A sorted list containing the same elements as the set.
    """
    def __init__(self, int_set : set[int]):
        self.int_set = int_set.copy()
        int_list = list(int_set)
        int_list.sort()
        self.sorted_list = int_list

    @cache
    def sums_of_k_no_order(
            self,
            num : int,
            k : int,
            max_summand : int
        ) -> int:
        """
        Computes the number of ways to write a non-negative integer as the sum of k integers from a given sorted list of non-negative integers and where none of the summands exceeds a given value.
        
        Parameters
        ----------
        num : int
            A non-negative integer.
        k : int
            A positive integer.
        summands : set[int]
            A sorted list of non-negative integers.
        max_summand : int
            An integer such that the summands in the counted options don't exceed this.

        Returns
        -------
        int
            The number of ways to write num as the sum of k numbers from summands, none of which exceeds max_summand.
        """
        if (k == 0):
            return int(num == 0)
        if (k == 1):
            return int((num <= max_summand) and (num in self.int_set))
        if (num < self.sorted_list[0]):
            return 0
        
        result = 0
        # iterate over the highest number in the sum
        for summand in self.sorted_list:
            if(summand > max_summand):
                break
            new_max_summand = np.min([num - summand, summand])
            result += self.sums_of_k_no_order(
                num - summand,
                k - 1,
                new_max_summand
            )
        
        return result

    def sums_no_order(
            self,
            num : int,
        ) -> int:
        """
        Computes the number of ways to write a number as the sum of elements from int_set, where different orderings of the same way count as one.
        """
        if(self.sorted_list[0] == 0):
            return float('inf')
        res = 0
        for k in range(1, num+1):
            res += self.sums_of_k_no_order(num, k, num)
        return res

@cache
def sums_of_k_naturals_no_order(num : int, k : int, max_summand : int):
    if (k < 1):
        return 0
    if (num in {0,1}):
        return 1
    if (k == 1):
        return (num <= max_summand)
    result = 0
    # iterate over the highest number in the sum
    for i in range(1, max_summand+1):
        new_max_summand = np.min([num - i, i])
        result += sums_of_k_naturals_no_order(num-i, k-1, new_max_summand)
    return result

def sums_of_k_naturals(
        num : int,
        k : int,
        order = False,
        zeros = False
    ):
    """
    Returns the number of ways to write a given number as the sum of natural numbers.
    
    Parameters
    ----------
    num : int
        A natural number.
    k : int
        A natural number.
    order : boolean
        A boolean value determening if the program counts different orders of the same values.
    zeros : boolean
        A boolean value determining if the program counts 0 as being an optional value.

    Returns
    -------
    int
        The number of ways to write n as the sum of k natural numbers. If order = True, the ordering of the numbers matters, otherwise it doesn't. If zeros = False, zeros cannot appear in the sum.
    """
    
    '''
    If we consider the stars-and-bars method, dividing stars between the bars such that there aren't zeros is the same as dividing k fewer stars.
    '''
    num -= k * (not zeros)

    if(order):
        return binom(num + k - 1, k - 1)
    else:
        return sums_of_k_naturals_no_order(num, k, num)

        '''
        less efficient method:
        
        return gaussian_binomial(
                    num + k, k, reduced = True
                ).coeff(var('q')**num)
        '''

@cache
def sums_of_naturals_no_order(num : int, max_summand : int):
    if num in {0,1}:
        return num
    # count 1 if the number is allowed to be written as itself
    result = (num <= max_summand)
    # iterate over the highest number in the sum
    for i in range(1, max_summand+1):
        new_max_summand = np.min([num - i, i])
        result += sums_of_naturals_no_order(num-i, new_max_summand)
    return result


def sums_of_naturals(
        num : int,
        order = False
    ):
    """
    Returns the number of ways to write a given number as the sum of natural numbers.
    
    Parameters
    ----------
    num : int
        A natural number.
    order : boolean
        A boolean value determening if the program counts different orders of the same values.

    Returns
    -------
    int
        The number of ways to write n as the sum of natural numbers. If order = True, the ordering of the numbers matters, otherwise it doesn't.
    """
    if(not order): 
        return sums_of_naturals_no_order(num, num)
    
    res = 0
    for k in range(1, num + 1):
        res += sums_of_k_naturals(
                    num = num,
                    k = k,
                    order=True,
                    zeros=False
                )
    return res

if __name__ == "__main__":
    list_ = [chr(i) for i in range(ord('a'), ord('n')+1)]
    generator = sublist_generator(list_, 4)
    print(next(generator))
    print(next(generator))
    print(next(generator))
    print(generator.send("skip=1"))
    print(next(generator))
    print(next(generator))
    print(generator.send("skip=2"))
    print(generator.send("skip=2"))
