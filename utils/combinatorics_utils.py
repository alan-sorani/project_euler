import numpy as np
import sympy
from numpy import pi
from math import comb as binom
from math import factorial
from sympy import var, I
from typing import Callable
from functools import cache

def increment_sublist_index(
        indices : list[int],
        max_index : int,
        skip : int = 0
    ):
    """
    Increments the indices for a sublist as generated by sublist_generator, in left-to-right lexicographic order.

    Parameters
    ----------
    indices : list[int]
        An increasing list of integers.
    max_index : int
        The maximum possible value for the indices.
    skip : int
        A number that determines how many indices from the right cannot be incremented.

    Returns
    -------
    boolean
        True, unless indices are all maxed out in which case this returns False.
    """
    if(skip >= len(indices)):
        raise ValueError("Received value of skip variable exceeds maximal possible value.")
    if(indices == [i + max_index - len(indices) for i in range(len(indices))]):
        return False
    incremented_index = None
    incremented_value = None
    for i in range(len(indices) - 1 - skip, -1, -1):
        if((indices[i] < max_index) and ((i == len(indices) - 1) or (indices[i] + 1 < indices[i+1]))):
            indices[i] += 1
            incremented_index = i
            incremented_value = indices[i]
            break
    new_value = incremented_value + 1
    for i in range(incremented_index+1, len(indices), 1):
        indices[i] = new_value
        new_value += 1
    return True

def sublist_generator(
        list_ : list,
        size : int
    ):
    """
    Returns a generator for sublists of a given size, of a list.

    Parameters
    ----------
    list_ : list
        A set.
    size : int
        An integer determining the size for subsets of the set.

    Yields
    ------
    list
        Subsets of the list, of the specified size, where the subsets are given by list_[indices] where indices increase in left-to-right-lexicographic order on size-tuples of different indices from 0 to len(list_) - 1.

    Notes
    -----
    The generator can receive as input a value of the form "skip = n" for an integer n. If this is given, elements will be skipped until the right-most possible index that is at least n steps from the right is increased.
    """
    length = len(list_)
    if(size > length):
        return
    indices = [i for i in range(size)]
    stop = False
    while(not stop):
        sublist = [list_[index] for index in indices]
        input = yield sublist
        if(input == None):
            stop = not increment_sublist_index(indices, len(list_) - 1)
            continue
        if(input[:4] == "skip"):
            try:
                skip = int(input.split("=")[1])
            except ValueError:
                "Generator unable to handle received value." 
            stop = not increment_sublist_index(indices, len(list_) - 1, skip)
            continue
        raise ValueError("Generator unable to handle received value.")

@cache
def sums_of_k_naturals_no_order(num : int, k : int, max_summand : int):
    if (k < 1):
        return 0
    if (num in {0,1}):
        return 1
    if (k == 1):
        return (num <= max_summand)
    result = 0
    # iterate over the highest number in the sum
    for i in range(1, max_summand+1):
        new_max_summand = np.min([num - i, i])
        result += sums_of_k_naturals_no_order(num-i, k-1, new_max_summand)
    return result

def sums_of_k_naturals(
        num : int,
        k : int,
        order = False,
        zeros = False
    ):
    """
    Returns the number of ways to write a given number as the sum of natural numbers.
    
    Parameters
    ----------
    num : int
        A natural number.
    k : int
        A natural number.
    order : boolean
        A boolean value determening if the program counts different orders of the same values.
    zeros : boolean
        A boolean value determining if the program counts 0 as being an optional value.

    Returns
    -------
    int
        The number of ways to write n as the sum of k natural numbers. If order = True, the ordering of the numbers matters, otherwise it doesn't. If zeros = False, zeros cannot appear in the sum.
    """
    
    '''
    If we consider the stars-and-bars method, dividing stars between the bars such that there aren't zeros is the same as dividing k fewer stars.
    '''
    num -= k * (not zeros)

    if(order):
        return binom(num + k - 1, k - 1)
    else:
        return sums_of_k_naturals_no_order(num, k, num)

        '''
        less efficient method:
        
        return gaussian_binomial(
                    num + k, k, reduced = True
                ).coeff(var('q')**num)
        '''

@cache
def sums_of_naturals_no_order(num : int, max_summand : int):
    if num in {0,1}:
        return num
    # count 1 if the number is allowed to be written as itself
    result = (num <= max_summand)
    # iterate over the highest number in the sum
    for i in range(1, max_summand+1):
        new_max_summand = np.min([num - i, i])
        result += sums_of_naturals_no_order(num-i, new_max_summand)
    return result


def sums_of_naturals(
        num : int,
        order = False
    ):
    """
    Returns the number of ways to write a given number as the sum of natural numbers.
    
    Parameters
    ----------
    num : int
        A natural number.
    order : boolean
        A boolean value determening if the program counts different orders of the same values.

    Returns
    -------
    int
        The number of ways to write n as the sum of natural numbers. If order = True, the ordering of the numbers matters, otherwise it doesn't.
    """
    if(not order): 
        return sums_of_naturals_no_order(num, num)
    
    res = 0
    for k in range(1, num + 1):
        res += sums_of_k_naturals(
                    num = num,
                    k = k,
                    order=True,
                    zeros=False
                )
    return res

if __name__ == "__main__":
    list_ = [chr(i) for i in range(ord('a'), ord('n')+1)]
    generator = sublist_generator(list_, 4)
    print(next(generator))
    print(next(generator))
    print(next(generator))
    print(generator.send("skip=1"))
    print(next(generator))
    print(next(generator))
    print(generator.send("skip=2"))
    print(generator.send("skip=2"))
